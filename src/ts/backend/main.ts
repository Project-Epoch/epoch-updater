import { app, ipcMain, shell, dialog as electronDialog } from "electron";
import { ClientManager } from "./client";
import { UpdateManager, UpdateState } from "./updater";
import { WindowManager } from "./window";
import { SettingsManager } from "./settings";

/**
 * This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack 
 * plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on 
 * whether you're running in development or production).
 */
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

class Main {
    constructor() {
        this.registerIPC();

        /** Electron App Events. */
        app.on('ready', this.onReady);
        app.on('window-all-closed', this.onAllWindowClosed);
        app.on('before-quit', () => { this.onAppQuit(); });
    }

    /**
     * Registers our Inter Process Communications.
     */
    registerIPC() {
        ipcMain.on('window-rendered', this.onWindowRendered.bind(this));
        ipcMain.on('window-close', () => { app.quit() });
        ipcMain.on('window-minimize', () => { WindowManager.get().minimize() });
        ipcMain.on('link-clicked', (event, args) => { shell.openExternal(args); });
        ipcMain.on('choose-install-directory', () => { 
            ClientManager.chooseDirectory(() => {
                setTimeout(() => {
                    UpdateManager.setState(UpdateState.GET_MANIFEST);
                    UpdateManager.getManifest();
                }, 1000);
            });
        });
        ipcMain.on('refresh-update-state', () => { UpdateManager.refresh(); });
        ipcMain.on('update-button-click', () => { UpdateManager.downloadUpdates(); });
        ipcMain.on('on-cancel-button-clicked', () => { UpdateManager.cancel(); });
        ipcMain.on('play-game', () => { 
            ClientManager.open();

            setTimeout(() => {
                app.quit();
            }, 1000);
        });

        ipcMain.handle('settings-get-current-directory', async () => {
            return ClientManager.getClientDirectory();
        });

        ipcMain.handle('settings-choose-new-directory', async () => {
            const result = await electronDialog.showOpenDialog(WindowManager.get(), {
                title: 'Choose New Client Directory',
                properties: ['openDirectory']
            });
            if (result.canceled || result.filePaths.length === 0) {
                return null;
            }
            return result.filePaths[0];
        });

        ipcMain.handle('settings-save-new-directory', async (event, newPath: string) => {
            if (!newPath || typeof newPath !== 'string') {
                WindowManager.get().webContents.send('settings-directory-change-error', 'Invalid path provided.');
                return false;
            }
            try {
                if (ClientManager.isEmpty(newPath) || ClientManager.isWarcraftDirectory(newPath)) {
                     if (!ClientManager.isEmpty(newPath) && !ClientManager.isCorrectLocale(newPath)) {
                        WindowManager.get().webContents.send('settings-directory-change-error', 'Invalid World of Warcraft Locale - enUS Required.');
                        return false;
                    }
                    ClientManager.setClientDirectory(newPath);
                    UpdateManager.notifyDirectoryChanged();
                     WindowManager.get().webContents.send('client-directory-loaded', newPath);
                    return true;
                } else {
                     WindowManager.get().webContents.send('settings-directory-change-error', 'Chosen directory is not empty and not a valid World of Warcraft directory, or is an invalid locale.');
                    return false;
                }
            } catch (error) {
                console.error("Error saving new directory:", error);
                WindowManager.get().webContents.send('settings-directory-change-error', `Error saving directory: ${error.message}`);
                return false;
            }
        });
    }

    /**
     * Fires when the app is quitting.
     */
    onAppQuit() {
        if (UpdateManager.getState() === UpdateState.DOWNLOADING) {
            UpdateManager.cancel();
        }
    }

    /**
     * When the DOM Content has been loaded we start setting 
     * up our initial updater state.
     */
    onWindowRendered() {
        const mainWindow = WindowManager.get();
        mainWindow.show();

        const currentDir = ClientManager.getClientDirectory();
        const hasDir = ClientManager.hasClientDirectory();
        const isWarcraftDir = hasDir && typeof currentDir === 'string' && ClientManager.isWarcraftDirectory(currentDir);

        if (isWarcraftDir) {
            mainWindow.webContents.send('client-directory-loaded', currentDir);
            UpdateManager.setState(UpdateState.GET_MANIFEST);
            UpdateManager.getManifest();
        } else {
            UpdateManager.setState(UpdateState.SETUP);
        }
    }

    /**
     * This method will be called when Electron has finished 
     * initialization and is ready to create browser windows. 
     * Some APIs can only be used after this event occurs.
     */
    onReady() {
        WindowManager.create(MAIN_WINDOW_WEBPACK_ENTRY, MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY);
    }

    /**
     * Fired when all windows are closed.
     */
    onAllWindowClosed() {
        app.quit();
    }
}

export default Main;